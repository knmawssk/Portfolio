import logging
import random
from datetime import datetime
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ConversationHandler,
    ContextTypes,
)

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Состояния разговора
(
    NAME, AGE, MEDICATION, DIAGNOSIS,
    TEST_QUESTIONS, SHARE_EXPERIENCE,
    TEST_PANIC_QUESTIONS,
    CHOOSE_FIELD, EDIT_NAME, EDIT_AGE,
    EDIT_MEDICATION, EDIT_DIAGNOSIS,
    MEDICATION_COUNT, MEDICATION_TYPE, MEDICATION_NAME,
    MEDICATION_REMINDER, MEDICATION_TIME, MEDICATION_COMPLETE,
NEWS_TYPE, NEWS_CATEGORY, IN_DIALOG
) = range(21)

# Клавиатура для количества препаратов
med_count_keyboard = ReplyKeyboardMarkup(
    [["1", "2", "3", "4", "5+"]],
    resize_keyboard=True
)


dialog_keyboard = ReplyKeyboardMarkup([['Завершить диалог']], resize_keyboard=True)

TEST_TOTAL = 5
PANIC_TEST_TOTAL = 5

# Главное меню
main_menu = ReplyKeyboardMarkup(
    [
        ["Рассказать о себе", "Пройти тест уровня стресса"],
        ["Мои результаты уровня стресса", "Выговориться"],
        ["Срочная помощь", "Горячая линия"],
["Оценка состояния"]
    ],
    resize_keyboard=True
)

# Меню управления данными
edit_data_menu = ReplyKeyboardMarkup(
    [
        ["Изменить данные", "Сбросить данные"],
        ["Вернуться в меню"]
    ],
    resize_keyboard=True
)


#тест на психолога или психиатра
ASSESSMENT_QUESTIONS, ASSESSMENT_RESULT = range(100, 102)  # Просто чтобы не пересеклось

ASSESSMENT_QUESTIONS_LIST = [
    "Как часто в последнее время ты чувствуешь усталость, даже после отдыха?",
    "Бывает ли тебе сложно сосредоточиться на повседневных делах?",
    "Часто ли ты переживаешь из-за будущего?",
    "Бывает ли у тебя чувство, что эмоции сложно контролировать?",
    "Есть ли у тебя трудности с принятием решений?",
    "Возникает ли у тебя раздражение без явной причины?",
    "Тебе сложно поддерживать отношения с близкими или друзьями?",
    "Есть ли у тебя проблемы со сном — например, бессонница или слишком долгий сон?",
    "Бывает ли у тебя ощущение, что жизнь потеряла смысл или цель?",
    "Переживаешь ли ты сильное беспокойство или панические атаки?",
    "Замечал(а) ли ты резкие перепады настроения без явной причины?",
    "Есть ли у тебя мысли о причинении вреда себе?",
    "Бывает ли, что ты не можешь ясно мыслить или сосредоточиться?",
    "Замечал(а) ли ты, что твои эмоции или действия иногда выходят из-под контроля?",
    "Случалось ли тебе испытывать сильную тревогу без объяснимой причины?",
    "Испытываешь ли ты сложности на работе или учёбе из-за эмоционального состояния?",
    "Ты часто чувствуешь себя отстранённым(ой) или как будто смотришь на мир со стороны?",
    "Замечал(а) ли ты когда-нибудь, что твои мысли бегают слишком быстро или, наоборот, замедлены?",
    "Испытываешь ли ты трудности в управлении своими финансами из-за эмоциональных проблем?",
    "Возникают ли у тебя сложности в выполнении повседневных обязанностей?"
]

# Номера вопросов по порядку (с нуля)
DIAGNOSTIC_GROUPS = {
    'депрессивные симптомы': [0, 1, 8, 12, 19],  # усталость, концентрация, смысл жизни, мышление, повседневные задачи
    'тревожные симптомы': [2, 5, 9, 14, 15],  # беспокойство, раздражение, паника, тревога, работа/учеба
    'биполярные симптомы': [10, 13, 17],  # перепады настроения, импульсивность, скачки мыслей
    'ПРЛ-подобные симптомы': [3, 6, 11],  # эмоции сложно контролировать, отношения, мысли о вреде
    'диссоциативные симптомы': [16],  # отстранённость
}



DIAGNOSTIC_INFO = {
    'депрессивные симптомы': (
        "Депрессивные симптомы — это сочетание признаков, которые могут включать сильную усталость, потерю интереса к привычным занятиям, сложности с концентрацией и ощущение безнадёжности. "
        "Иногда такие состояния могут возникать как естественная реакция на стресс или усталость. Однако если эти чувства продолжаются дольше двух недель, "
        "повторяются часто и мешают повседневной жизни, имеет смысл поговорить с психологом или психиатром. Специалист поможет разобраться, "
        "с чем связаны такие ощущения, и предложит способы поддержки. Помни, это не диагноз, а лишь ориентир для внимательности к себе."
    ),
    'тревожные симптомы': (
        "Тревожные симптомы — это постоянное внутреннее беспокойство, чрезмерные волнения о будущем, раздражительность, напряжение или даже панические атаки. "
        "Временами тревога может быть естественной — например, перед экзаменами или важными событиями. "
        "Но если тревожность мешает спать, работать или отдыхать, важно обсудить это с психологом. Специалист поможет научиться управлять тревогой "
        "и подскажет техники расслабления. Это не диагноз, а лишь намёк на то, что возможно стоит уделить себе внимание."
    ),
    'биполярные симптомы': (
        "Биполярные симптомы — это чередование периодов, когда настроение поднимается (человек полон энергии, может мало спать и быть очень активным), "
        "и периодов снижения настроения (упадок сил, безразличие, грусть). Небольшие перепады настроения — это часть жизни любого человека. "
        "Но если такие изменения резкие, мешают работе, сну и отношениям, консультация со специалистом может быть полезна. "
        "Важно помнить, что такие симптомы не обязательно означают наличие биполярного расстройства — только врач может поставить диагноз после тщательной беседы и наблюдения."
    ),
    'ПРЛ-подобные симптомы': (
        "Пограничные (ПРЛ-подобные) симптомы могут включать очень сильные и быстро меняющиеся эмоции, страх быть покинутым, трудности в отношениях, "
        "а также мысли о причинении вреда себе. Такие чувства иногда возникают у людей в периоды сильного стресса или эмоциональной нестабильности. "
        "Если это повторяется часто или приводит к сложностям в жизни, лучше обсудить это с психотерапевтом. "
        "Специалист поможет понять причины таких реакций и научит справляться с ними безопасными способами. "
        "Это не диагноз, а подсказка быть внимательным к своему эмоциональному состоянию."
    ),
    'диссоциативные симптомы': (
        "Диссоциативные симптомы — это ощущение отстранённости от происходящего, как будто смотришь на жизнь со стороны или находишься как в тумане. "
        "Такие состояния могут возникать из-за сильной усталости, стресса или переутомления. "
        "Если они случаются редко и проходят сами, это обычно не опасно. Но если такие ощущения становятся частыми или вызывают беспокойство, "
        "полезно поговорить с психологом. Специалист поможет разобраться, что происходит, и подскажет, как вернуть ощущение стабильности. "
        "Это не диагноз, а просто сигнал быть внимательнее к себе."
    ),
}


# выговориться
# Клавиатура для типа новости
news_type_keyboard = ReplyKeyboardMarkup([['Хорошая новость', 'Плохая новость'], ['Назад']], resize_keyboard=True)

# Клавиатуры для категорий
good_news_keyboard = ReplyKeyboardMarkup([
    ['Учеба', 'Работа', 'Семья'],
    ['Здоровье', 'Личные отношения', 'Хобби и увлечения'],
    ['Финансы', 'Путешествия', 'Назад']
], resize_keyboard=True)

bad_news_keyboard = ReplyKeyboardMarkup([
    ['Учеба', 'Работа', 'Семья'],
    ['Здоровье', 'Личные отношения', 'Хобби и увлечения'],
    ['Финансы', 'Путешествия', 'Назад']
], resize_keyboard=True)

# Меню выбора поля для изменения
choose_field_menu = ReplyKeyboardMarkup(
    [
        ["Имя", "Возраст"],
        ["Препараты", "Диагнозы"],
        ["Вернуться в меню"]
    ],
    resize_keyboard=True
)

# Клавиатура после теста
result_keyboard = ReplyKeyboardMarkup(
    [
        ["Расскажи побольше", "Выговориться"],
        ["Вернуться в меню"]
    ],
    resize_keyboard=True
)

# Клавиатура для выбора возраста
age_keyboard = ReplyKeyboardMarkup(
    [["12-18", "19-25", "26-35", "36-45", "46-60"]],
    resize_keyboard=True
)

# Клавиатура для ответов Да/Нет
yes_no_keyboard = ReplyKeyboardMarkup([["Да", "Нет"]], resize_keyboard=True)

# Клавиатура для ответов на тест
test_keyboard = ReplyKeyboardMarkup(
    [["Никогда", "Редко", "Иногда", "Часто", "Постоянно"]],
    resize_keyboard=True
)

# Вопросы теста на стресс
TEST = [
    "1. Чувствуете мышечное напряжение?",
    "2. Беспокоят головные боли?",
    "3. Есть проблемы со сном?",
    "4. Чувствуете беспричинную усталость?",
    "5. Раздражаетесь по мелочам?"
]

# Вопросы теста на паническая атака
PANIC_TEST = [
    "1. Испытывали ли вы внезапный сильный страх или дискомфорт в последнее время?",
    "2. Было ли у вас учащенное сердцебиение или пульс?",
    "3. Ощущали ли вы дрожь или тремор?",
    "4. Была ли у вас одышка или чувство удушья?",
    "5. Чувствовали ли вы боль или дискомфорт в груди?"
]

# Базовые советы по стрессу
STRESS_ADVICE = {
    "low": "✅ Низкий уровень стресса (0-5 баллов)",
    "medium": "⚠️ Умеренный уровень стресса (6-10 баллов)",
    "high": "🔥 Высокий уровень стресса (11-15 баллов)",
    "critical": "🚨 Критический уровень стресса (16-20 баллов)"
}

# Подробные инструкции по стрессу
EXTENDED_ADVICE = {
    "low": (
        "🔍 Простые ежедневные практики:\n\n"
        "1. 📝 «3 хороших события» (2 минуты перед сном):\n"
        "   - Запишите 3 приятных момента дня\n"
        "   - Напишите, как вы к ним причастны\n"
        "   Пример: «Коллега улыбнулся — я первый поздоровался»\n\n"
        "2. 🚶 «Осознанная прогулка» (5 минут):\n"
        "   - Идите медленно, считая шаги\n"
        "   - На каждом вдохе говорите «спокойствие»\n"
        "   - На выдохе — «расслабление»"
    ),
    "medium": (
        "🔍 Техники при напряжении:\n\n"
        "1. 🌬️ «Дыхание 5-5-5» (3 минуты):\n"
        "   - Сядьте прямо, рука на животе\n"
        "   - Вдох через нос 5 сек (живот выпячивается)\n"
        "   - Задержка 5 сек\n"
        "   - Выдох через рот 5 сек (как будто дуете на свечу)\n"
        "   - Повторить 5 циклов\n\n"
        "2. 🧊 «Ледяное заземление»:\n"
        "   - Возьмите кубик льда в руку\n"
        "   - Сосредоточьтесь на ощущениях:\n"
        "     • Сначала холодно\n"
        "     • Потом покалывает\n"
        "     • Затем тает и теплеет"
    ),
    "high": (
        "🔍 Срочная помощь при стрессе:\n\n"
        "1. 🏠 «5-4-3-2-1» (3 минуты):\n"
        "   - Назовите 5 предметов вокруг\n"
        "   - 4 вещи, к которым можно прикоснуться\n"
        "   - 3 звука, которые слышите\n"
        "   - 2 запаха вокруг\n"
        "   - 1 вкус во рту\n\n"
        "2. 🤲 «Безопасное место» (5 минут):\n"
        "   - Закройте глаза\n"
        "   - Представьте самое спокойное место\n"
        "   - Добавьте детали: температура, звуки\n"
        "   - Дышите глубоко, «побудьте» там"
    ),
    "critical": (
        "🔍 Немедленные действия:\n\n"
        "1. 📞 Позвоните:\n"
        "   - 150 (круглосуточная помощь)\n"
        "   - 112 (экстренные службы)\n\n"
        "2. 🚶 Физические действия:\n"
        "   - Медленно походите по комнате\n"
        "   - Сжимайте-разжимайте кулаки 10 раз\n"
        "   - Выпейте воды мелкими глотками\n\n"
        "3. 👥 Контакт с близким:\n"
        "   - Отправьте сообщение: «Мне плохо»\n"
        "   - Включите голосовую запись (даже молча)"
    )
}

# Техники для панических атак с поддержкой
PANIC_TECHNIQUES = {
    0: {
        "message": (
            "🌸 *Вы молодцы, что следите за своим состоянием!*\n"
            "Сейчас всё в порядке, но профилактика никогда не помешает:\n\n"
            "🧘 **Техника 'Якорение'** (2 минуты):\n"
            "1. Сядьте удобно, поставьте обе стопы на пол\n"
            "2. Положите руку на сердце, почувствуйте его ритм\n"
            "3. Медленно скажите: *«Я в безопасности, я спокоен/спокойна»*\n"
            "4. Повторите 3 раза, с каждым разом замедляя речь\n\n"
            "*Вы уже делаете важный шаг к заботе о себе!* 💖"
        ),
        "keyboard": main_menu
    },
    1: {
        "message": (
            "🌿 *Вы справляетесь лучше, чем думаете!*\n"
            "Небольшая тревога — это нормально. Попробуем эту технику:\n\n"
            "🔄 **Техника 'Перезагрузка'** (3 минуты):\n"
            "1. *Вдохните* глубоко через нос (на 4 счёта)\n"
            "2. *Задержите* дыхание (на 2 счёта)\n"
            "3. *Выдохните* через сложенные трубочкой губы (на 6 счётов)\n"
            "4. *Похлопайте* себя по плечам крест-накрест 10 раз\n\n"
            "*Видите? Вы уже контролируете ситуацию!* 🌈"
        ),
        "keyboard": main_menu
    },
    2: {
        "message": (
            "💪 *Вы сильнее, чем вам кажется!*\n"
            "Давайте вместе справимся с этим состоянием:\n\n"
            "❄️ **Техника 'Ледяной щит'** (экстренная):\n"
            "1. Возьмите *2 кубика льда* (или холодные предметы)\n"
            "2. Держите в руках, сосредоточьтесь на ощущениях:\n"
            "   - *«Я чувствую холод»*\n"
            "   - *«Я чувствую, как лёд тает»*\n"
            "   - *«Я чувствую возвращение тепла»*\n"
            "3. Повторите про себя: *«Это пройдет, я в порядке»*\n\n"
            "*Вы уже молодец, что работаете над своим состоянием!* 🌟"
        ),
        "keyboard": ReplyKeyboardMarkup(
            [["Горячая линия"], ["Я справился(ась)"]],
            resize_keyboard=True
        )
    },
    3: {
        "message": (
            "🛡️ *Вы не одни, я здесь, чтобы помочь!*\n"
            "Сейчас важно сосредоточиться на дыхании:\n\n"
            "🎈 **Техника 'Воздушный шар'** (экстренная):\n"
            "1. *Сядьте на пол*, обопритесь спиной о стену\n"
            "2. Представьте перед собой *большой воздушный шар*\n"
            "3. *Медленно надувайте* его в воображении на вдохе (4 сек)\n"
            "4. *Задержите* дыхание (2 сек)\n"
            "5. *Сдувайте* шар на выдохе (6 сек)\n"
            "6. Повторите *5 циклов*, не торопитесь\n\n"
            "*Вы уже делаете всё правильно!* 💫\n"
            "Если станет тяжело — сразу нажмите «Горячая линия»"
        ),
        "keyboard": ReplyKeyboardMarkup(
            [["Горячая линия"], ["Я начинаю дышать"]],
            resize_keyboard=True
        )
    }
}

# выговориться
DIALOG_RESPONSES = {
    'хорошая новость': {
        'Учеба': [
            "Ты просто молодец! Я горжусь твоими достижениями!",
            "Как круто! Продолжай в том же духе, ты на правильном пути!",
            "Твои успехи вдохновляют! Так держать!",
            "Отличная работа! Твой труд заметен и ценится!",
            "Ты реально преуспеваешь, и это впечатляет!",
            "Каждый твой шаг в учебе — это прогресс! Горжусь тобой!",
            "Ты демонстрируешь замечательные результаты! Не останавливайся!",
            "Твоя усердность в учебе приносит плоды! Это восхитительно!",
            "Ты показываешь, что значит настоящая целеустремленность!",
            "Такой прогресс в учебе заслуживает самых высоких похвал!"
        ],
        'Работа': [
            "Как здорово! Ты движешься к своей цели!",
            "Здорово, что твоя работа приносит такие плоды!",
            "Рад за тебя! Пусть твоя карьера только набирает обороты!",
            "Ты реально достиг больших успехов! Молодец!",
            "Это классно! Продолжай развиваться и достигать новых вершин!",
            "Твои профессиональные достижения впечатляют!",
            "Ты делаешь важные шаги в карьере! Это замечательно!",
            "Твои успехи на работе мотивируют других!",
            "Видно, что ты вкладываешь душу в свою работу! Это чувствуется!",
            "Ты создаешь прекрасные результаты! Пусть будет еще больше успехов!"
        ],
        'Семья': [
            "Как здорово! Семья — это самое важное!",
            "Это замечательно! Пусть в доме всегда будет тепло и гармония!",
            "Так приятно слышать такие новости о семье!",
            "Пусть в вашей семье всегда царит любовь и взаимопонимание!",
            "Отлично, что все хорошо! Семья — это поддержка на протяжении всей жизни!",
            "Твоя семья — это твоя крепость! Как здорово, что у вас все хорошо!",
            "Семейное счастье — это бесценно! Рада за вас!",
            "Видно, что в вашей семье царит уважение и забота!",
            "Такие теплые семейные моменты делают жизнь прекрасной!",
            "Ваша семейная история вдохновляет на добрые дела!"
        ],
        'Здоровье': [
            "Отлично, что здоровье в порядке! Главное, чтобы все было стабильно!",
            "Рад за тебя, здоровье — это важно! Так держать!",
            "Здоровье всегда в приоритете. Рад, что все хорошо!",
            "Как замечательно, что все наладилось! Пусть так и будет!",
            "Здоровье — это главное, и здорово, что ты чувствуешь себя хорошо!",
            "Твое хорошее самочувствие — это лучшая новость!",
            "Забота о здоровье — это инвестиция в счастливое будущее!",
            "Видно, что ты ответственно подходишь к своему здоровью!",
            "Твое тело благодарит тебя за заботу! Продолжай в том же духе!",
            "Хорошее здоровье открывает все двери! Рада за тебя!"
        ],
        'Личные отношения': [
            "Как замечательно! Пусть в личной жизни будет только радость!",
            "Здорово, что все так хорошо! Пусть ваше счастье будет долгим!",
            "Ты заслуживаешь счастья в личной жизни, рад за тебя!",
            "Как приятно слышать, что в личной жизни все стабильно!",
            "Пусть ваши отношения будут полны взаимопонимания и любви!",
            "Твои отношения — пример гармонии и уважения!",
            "Видно, что вы с партнером цените друг друга! Это прекрасно!",
            "Такие крепкие отношения делают жизнь по-настоящему счастливой!",
            "Ваша любовь вдохновляет окружающих на теплые чувства!",
            "Пусть каждый день приносит вам новые радости вместе!"
        ],
        'Хобби и увлечения': [
            "Как здорово, что ты продолжаешь заниматься любимым делом!",
            "Увлечения — это то, что делает жизнь ярче! Рад, что ты не останавливаешься!",
            "Здорово, что хобби приносит радость! Это очень важно!",
            "Как классно, что ты не забрасываешь свои увлечения!",
            "Твои увлечения делают тебя уникальным(ой)! Молодец!",
            "Твое хобби — это отражение твоей творческой натуры!",
            "Занимаясь любимым делом, ты заряжаешься энергией!",
            "Такие интересные увлечения обогащают твою жизнь!",
            "Ты вкладываешь душу в свое хобби, и это видно!",
            "Пусть твои увлечения приносят тебе еще больше вдохновения!"
        ],
        'Финансы': [
            "Как круто, что у тебя все в порядке с финансами! Пусть так и продолжится!",
            "Здорово! Пусть финансов все больше и больше!",
            "Рад за тебя! Пусть финансовое благополучие растет!",
            "Отлично! Уверен(на), что ты на верном пути к финансовому успеху!",
            "Как здорово, что твои усилия дают результаты в финансах!",
            "Твоя финансовая грамотность приносит плоды!",
            "Стабильность в финансах — это важное достижение!",
            "Ты умело управляешь своими ресурсами! Это достойно уважения!",
            "Финансовый успех — результат твоей продуманной стратегии!",
            "Пусть твои финансовые дела идут только вверх!"
        ],
        'Путешествия': [
            "Как круто! Пусть путешествия приносят тебе только положительные впечатления!",
            "Здорово, что ты путешествуешь! Пусть каждый новый маршрут будет уникальным!",
            "Как замечательно! Пусть поездки наполняют твою жизнь яркими моментами!",
            "Твои путешествия — это вдохновение для других! Пусть их будет больше!",
            "Здорово, что ты открыл(а) для себя новые места! Пусть каждое путешествие будет особенным!",
            "Каждая твоя поездка — это новая глава в книге твоей жизни!",
            "Путешествия расширяют кругозор! Рада, что ты это понимаешь!",
            "Ты умеешь находить прекрасное в каждом уголке мира!",
            "Твои рассказы о путешествиях заставляют мечтать!",
            "Пусть впереди тебя ждут еще более удивительные маршруты!"
        ]
    },
    'плохая новость': {
        'Учеба': [
            "Это бывает. Главное, что ты не останавливаешься и продолжаешь работать.",
            "Такие моменты бывают, но ты уже много сделал(а), и это важно.",
            "Не всегда все идет, как хотелось бы, но ты продолжишь двигаться вперед.",
            "Да, сейчас это тяжело. Но ты справляешься, и это главное.",
            "Иногда неудачи на пути, но ты все равно продолжаешь работать. Это ценно.",
            "Трудности в учебе — это временно. Ты обязательно преодолеешь их.",
            "Каждая проблема — это возможность научиться чему-то новому.",
            "Ты уже показал(а), что способен(на) на многое. Не сдавайся сейчас.",
            "Этот сложный период сделает тебя только сильнее.",
            "Помни, что даже великие ученые сталкивались с трудностями."
        ],
        'Работа': [
            "Не всегда все получается, но твоя настойчивость все равно стоит уважения.",
            "Бывают такие моменты, когда все не складывается. Но ты точно сможешь пройти через это.",
            "Трудности на работе — это неприятно, но они не определяют твою ценность.",
            "Ты сталкиваешься с трудностями, но ты не один(на) в этом. Ты справишься.",
            "Неудачи случаются, но ты все равно сильный(ая), и ты найдешь выход.",
            "Рабочие проблемы — это опыт, который сделает тебя профессионалом.",
            "Ты уже преодолевал(а) сложности раньше — сможешь и сейчас.",
            "Иногда нужно сделать шаг назад, чтобы потом прыгнуть вперед.",
            "Эта ситуация научит тебя находить нестандартные решения.",
            "Твоя карьера — это марафон, а не спринт. Главное — не сходить с дистанции."
        ],
        'Семья': [
            "Когда в семье проблемы, это всегда тяжело. Но ты не один(на), и все наладится.",
            "Семейные вопросы — это сложная вещь. Но ты справишься и с этим.",
            "Когда что-то не так с семьей, это всегда непросто. Но ты найдешь силы пройти через это.",
            "Семейные проблемы могут быть болезненными, но это пройдет. Ты выдержишь.",
            "Понимаю, как тебе тяжело. Но ты сильный(ая), и тебе удастся справиться.",
            "Семейные трудности проверяют отношения на прочность, но и укрепляют их.",
            "Даже в сложных ситуациях старайтесь сохранять уважение друг к другу.",
            "Время лечит. Дайте себе и близким возможность все обдумать.",
            "Иногда нужно просто переждать бурю — штиль обязательно наступит.",
            "Ваша семья уже переживала трудные времена — справитесь и сейчас."
        ],
        'Здоровье': [
            "Понимаю, как это тяжело. Но твое здоровье — это важнее всего, и ты обязательно поправишься.",
            "Ты сейчас переживаешь трудный период, но со временем все наладится.",
            "Когда здоровье дает сбои, это всегда сложно. Но ты найдешь силы, чтобы восстановиться.",
            "Это не самое легкое время, но ты справишься. Главное — заботиться о себе.",
            "Здоровье — это самое важное. Не торопись, все наладится.",
            "Слушай рекомендации врачей и верь в свое выздоровление.",
            "Твой организм обладает удивительной способностью к восстановлению.",
            "Даже маленькие улучшения — это шаг к полному выздоровлению.",
            "Не забывай, что психическое здоровье так же важно, как и физическое.",
            "Ты заслуживаешь качественного лечения и хорошего самочувствия."
        ],
        'Личные отношения': [
            "Когда в отношениях сложности, это всегда тяжело. Но ты справишься.",
            "Отношения — это непросто. Но ты знаешь, как двигаться дальше.",
            "В таких ситуациях всегда сложно, но ты найдешь путь вперед.",
            "Когда отношения переживают трудности, это всегда болезненно. Но ты все равно сможешь пройти через это.",
            "Сейчас тяжело, но ты умный(ая) и сможешь справиться с этим.",
            "Кризисы в отношениях — это возможность переосмыслить их.",
            "Честность и открытость помогут вам преодолеть этот этап.",
            "Иногда нужно дать друг другу пространство для размышлений.",
            "Если отношения важны для вас обоих, вы найдете выход.",
            "Любовь проходит испытания, но настоящие чувства выдерживают их."
        ],
        'Хобби и увлечения': [
            "Когда увлечение не приносит радости, это бывает. Но ты все равно сможешь вернуться к этому.",
            "Иногда нужно сделать паузу. Твое увлечение будет ждать тебя, когда ты будешь готов(а).",
            "Это не конец твоего хобби. Ты вернешься к этому, как только почувствуешь себя готовым(ой).",
            "Когда что-то не получается в хобби, это расстраивает. Но ты снова вернешься к этому.",
            "Ты переживаешь трудный момент, но это пройдет, и ты снова найдешь в этом радость.",
            "Возможно, стоит попробовать новый подход к своему увлечению.",
            "Творческие кризисы бывают у всех — это часть процесса.",
            "Не ставь себе слишком высокую планку — хобби должно приносить удовольствие.",
            "Иногда полезно взглянуть на свое увлечение свежим взглядом.",
            "Ты найдешь новый источник вдохновения, просто дай себе время."
        ],
        'Финансы': [
            "Финансовые трудности бывают у всех. Ты точно сможешь справиться.",
            "В такие моменты важно не сдаваться. Ты все преодолеешь.",
            "Финансовые проблемы — это не конец, ты сможешь восстановить свою ситуацию.",
            "Это тяжело, но ты сильный(ая), и ты найдешь решение.",
            "Трудности с деньгами — это временно. Ты найдешь выход из ситуации.",
            "Грамотное планирование поможет тебе выйти из этого положения.",
            "Помни, что материальные трудности не определяют твою ценность.",
            "Эта ситуация научит тебя более разумному обращению с финансами.",
            "Даже небольшие шаги к улучшению финансовой ситуации важны.",
            "Ты найдешь способ увеличить доход или оптимизировать расходы."
        ],
        'Путешествия': [
            "Это временно, и ты снова сможешь отправиться в путешествие, когда все будет в порядке.",
            "Не расстраивайся, возможности для путешествий всегда будут.",
            "Трудности с путешествиями — это не конец. Ты обязательно увидишь мир.",
            "Сейчас не удается поехать, но ты сможешь это сделать, как только ситуация изменится.",
            "Ты пройдешь через это, и скоро снова сможешь отправиться в путь.",
            "Мечты о путешествиях помогут тебе пережить этот период.",
            "Используй это время для планирования будущих поездок.",
            "Иногда задержки спасают нас от непредвиденных проблем в пути.",
            "Когда ты все же отправишься в путешествие, оно будет еще ценнее.",
            "Пусть временные ограничения не лишают тебя мечты увидеть мир."
        ]
    }
}


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "👋 Привет! Я бот для работы со стрессом и тревогой. Выберите действие:",
        reply_markup=main_menu
    )

# Клавиатура для типов препаратов
med_type_keyboard = ReplyKeyboardMarkup(
    [
        ["Гормональные", "Антидепрессанты"],
        ["Для здоровья (анемия и др.)", "Другие"],
        ["Пропустить"]
    ],
    resize_keyboard=True
)

# Клавиатура для времени напоминаний
reminder_time_keyboard = ReplyKeyboardMarkup(
    [
        ["9:00", "12:00", "15:00"],
        ["18:00", "21:00", "Другое время"],
        ["Не нужно напоминание"]
    ],
    resize_keyboard=True
)

# Поддержка для разных типов препаратов
MEDICATION_SUPPORT = {
    "Гормональные": (
        "💊 *Гормональные препараты*\n\n"
        "Важно принимать их регулярно в одно и то же время. "
        "Если пропустили прием — следуйте инструкциям вашего врача. "
        "Помните, что ваше здоровье — главный приоритет! 🌸"
    ),
    "Антидепрессанты": (
        "🧠 *Антидепрессанты*\n\n"
        "Эти препараты требуют времени для проявления эффекта. "
        "Не прекращайте прием без консультации с врачом, даже если почувствовали улучшение. "
        "Вы на правильном пути к заботе о своем ментальном здоровье! 💪"
    ),
    "Для здоровья (анемия и др.)": (
        "❤️ *Препараты для здоровья*\n\n"
        "Регулярный прием поможет поддерживать ваше физическое состояние. "
        "Следите за своим самочувствием и не стесняйтесь обращаться к врачу при изменениях. "
        "Вы делаете важную работу по заботе о своем теле! 🌟"
    ),
    "Другие": (
        "🩺 *Другие препараты*\n\n"
        "Не забывайте принимать их согласно назначению врача. "
        "Если у вас есть вопросы о препаратах — всегда можно уточнить у специалиста. "
        "Вы молодец, что следите за своим лечением! 👍"
    )
}


async def get_medication(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"get_medication: text={update.message.text}")
    text = update.message.text
    if text == "Нет":
        context.user_data['medication'] = "Не принимает препараты"
        await update.message.reply_text(
            "Есть ли официальные медицинские диагнозы?",
            reply_markup=yes_no_keyboard
        )
        return DIAGNOSIS
    else:
        context.user_data['medication'] = "Принимает препараты"
        context.user_data['medications'] = []  # Инициализация списка препаратов
        await update.message.reply_text(
            "Сколько препаратов вы принимаете?",
            reply_markup=med_count_keyboard
        )
        return MEDICATION_COUNT  # Важно вернуть это состояние, а не DIAGNOSIS


async def start_assessment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['assessment_index'] = 0
    context.user_data['assessment_score'] = 0
    context.user_data['assessment_scores_by_group'] = {group: 0 for group in DIAGNOSTIC_GROUPS}
    await update.message.reply_text(
        "Этот тест поможет понять, стоит ли обратиться за поддержкой. Отвечай честно.\n\n"
        "На каждый вопрос отвечай одним из вариантов:\n\n"
        "0 — Никогда\n1 — Редко\n2 — Иногда\n3 — Часто\n4 — Почти всегда",
        reply_markup=ReplyKeyboardMarkup(
            [["0", "1", "2", "3", "4"]], resize_keyboard=True
        )
    )
    return await ask_next_assessment_question(update, context)

async def ask_next_assessment_question(update: Update, context: ContextTypes.DEFAULT_TYPE):
    index = context.user_data['assessment_index']
    if index < len(ASSESSMENT_QUESTIONS_LIST):
        await update.message.reply_text(ASSESSMENT_QUESTIONS_LIST[index])
        return ASSESSMENT_QUESTIONS
    else:
        return await show_assessment_result(update, context)


async def process_assessment_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text not in ["0", "1", "2", "3", "4"]:
        await update.message.reply_text("Пожалуйста, выбери цифру от 0 до 4.")
        return ASSESSMENT_QUESTIONS

    score = int(text)
    context.user_data['assessment_score'] += score
    index = context.user_data['assessment_index']

    # Прибавляем в группы
    for group, question_indices in DIAGNOSTIC_GROUPS.items():
        if index in question_indices:
            context.user_data['assessment_scores_by_group'][group] += score

    context.user_data['assessment_index'] += 1

    return await ask_next_assessment_question(update, context)

async def show_assessment_result(update: Update, context: ContextTypes.DEFAULT_TYPE):
    score = context.user_data['assessment_score']
    total_questions = len(ASSESSMENT_QUESTIONS_LIST)
    max_score = total_questions * 4
    group_scores = context.user_data['assessment_scores_by_group']
    possible_indicators = []

    for group, indices in DIAGNOSTIC_GROUPS.items():
        max_group_score = len(indices) * 4
        score = group_scores[group]
        percentage = (score / max_group_score) * 100

        # Если хотя бы 75% — мягко намекаем (порог можно регулировать)
        if percentage >= 75:
            possible_indicators.append(group)

    # Формируем сообщение
    if possible_indicators:
        indicators_text = "Кроме того, твои ответы показывают, что в некоторых аспектах ты испытываешь трудности, которые иногда встречаются при таких состояниях, как:\n\n"
        for ind in possible_indicators:
            indicators_text += f"— {ind.capitalize()}\n"
            indicators_text += f"{DIAGNOSTIC_INFO[ind]}\n\n"
        indicators_text += "\nЭто не диагноз, но это может быть полезной темой для разговора с профессионалом."
        await update.message.reply_text(indicators_text)

    percentage = (score / max_score) * 100

    if percentage < 25:
        message = (
            "Ты хорошо справляешься с повседневными задачами, и серьёзных поводов для беспокойства нет. "
            "Если когда-нибудь почувствуешь, что нужна поддержка, психолог всегда может помочь разобраться в эмоциях."
        )
    elif 25 <= percentage < 50:
        message = (
            "Есть некоторые признаки того, что эмоциональное состояние даётся тебе не всегда легко. "
            "Может быть полезно пообщаться с психологом, чтобы получить поддержку и разгрузиться."
        )
    elif 50 <= percentage < 75:
        message = (
            "Многие из твоих ответов говорят о том, что ты можешь испытывать заметные эмоциональные трудности. "
            "Разговор с психологом поможет прояснить ситуацию, а если потребуется, он подскажет, стоит ли обратиться к психиатру."
        )
    else:
        message = (
            "Твои ответы показывают, что сейчас у тебя непростой период. Очень важно не оставаться с этим наедине. "
            "Рекомендую обратиться к специалисту — психологу или психиатру, чтобы получить квалифицированную поддержку."
        )

    # Отправляем сообщение с результатами и кнопкой перепрохождения теста
    keyboard = [
        [InlineKeyboardButton("Перепройти тест", callback_data="restart_assessment")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(message, reply_markup=reply_markup)

    return ConversationHandler.END



async def get_medication_count(update: Update, context: ContextTypes.DEFAULT_TYPE):
    count = update.message.text
    if count == "5+":
        count = "5 и более"
    context.user_data['medication_count'] = count

    # Начинаем сбор информации о каждом препарате
    context.user_data['current_med'] = 1
    context.user_data['total_meds'] = int(count) if count.isdigit() else 5

    await update.message.reply_text(
        f"Препарат {context.user_data['current_med']} из {context.user_data['total_meds']}\n"
        "Выберите тип препарата:",
        reply_markup=med_type_keyboard
    )
    return MEDICATION_TYPE


async def get_medication_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    med_type = update.message.text
    if med_type == "Пропустить":
        context.user_data['current_med_type'] = "Не указан"
    else:
        context.user_data['current_med_type'] = med_type
        # Отправляем информацию о типе препарата
        await update.message.reply_text(
            MEDICATION_SUPPORT.get(med_type, MEDICATION_SUPPORT["Другие"]),
            reply_markup=ReplyKeyboardRemove()
        )

    await update.message.reply_text(
        "Введите название препарата:",
        reply_markup=ReplyKeyboardRemove()
    )
    return MEDICATION_NAME


async def get_medication_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    med_name = update.message.text
    context.user_data['current_med_name'] = med_name

    await update.message.reply_text(
        f"Хотите установить напоминание для '{med_name}'?",
        reply_markup=yes_no_keyboard
    )
    return MEDICATION_REMINDER


async def get_medication_reminder(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "Нет":
        # Сохраняем препарат без напоминания
        med_data = {
            'name': context.user_data['current_med_name'],
            'type': context.user_data.get('current_med_type', 'Не указан'),
            'reminder': None
        }
        context.user_data['medications'].append(med_data)

        # Проверяем, нужно ли запрашивать следующий препарат
        if context.user_data['current_med'] < context.user_data['total_meds']:
            context.user_data['current_med'] += 1
            await update.message.reply_text(
                f"Препарат {context.user_data['current_med']} из {context.user_data['total_meds']}\n"
                "Выберите тип препарата:",
                reply_markup=med_type_keyboard
            )
            return MEDICATION_TYPE
        else:
            return await complete_medication(update, context)
    else:
        await update.message.reply_text(
            "Выберите время напоминания:",
            reply_markup=reminder_time_keyboard
        )
        return MEDICATION_TIME


async def get_medication_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    time_str = update.message.text
    if time_str == "Другое время":
        await update.message.reply_text(
            "Введите время в формате ЧЧ:ММ (например, 08:30):",
            reply_markup=ReplyKeyboardRemove()
        )
        return MEDICATION_TIME
    elif time_str == "Не нужно напоминание":
        # Сохраняем препарат без напоминания
        med_data = {
            'name': context.user_data['current_med_name'],
            'type': context.user_data.get('current_med_type', 'Не указан'),
            'reminder': None
        }
        context.user_data['medications'].append(med_data)
    else:
        # Сохраняем препарат с напоминанием
        med_data = {
            'name': context.user_data['current_med_name'],
            'type': context.user_data.get('current_med_type', 'Не указан'),
            'reminder': time_str
        }
        context.user_data['medications'].append(med_data)

    # Проверяем, нужно ли запрашивать следующий препарат
    if context.user_data['current_med'] < context.user_data['total_meds']:
        context.user_data['current_med'] += 1
        await update.message.reply_text(
            f"Препарат {context.user_data['current_med']} из {context.user_data['total_meds']}\n"
            "Выберите тип препарата:",
            reply_markup=med_type_keyboard
        )
        return MEDICATION_TYPE
    else:
        return await complete_medication(update, context)


async def complete_medication(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Формируем текст со всеми препаратами
    meds_text = "💊 Ваши препараты:\n\n"
    for i, med in enumerate(context.user_data['medications'], 1):
        reminder = med['reminder'] if med['reminder'] else "без напоминания"
        meds_text += f"{i}. {med['name']} ({med['type']}) - {reminder}\n"

    await update.message.reply_text(
        meds_text + "\nСпасибо за информацию!",
        reply_markup=ReplyKeyboardRemove()
    )

    # Переходим к следующему вопросу
    await update.message.reply_text(
        "Есть ли официальные медицинские диагнозы?",
        reply_markup=yes_no_keyboard
    )
    return DIAGNOSIS


async def reset_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Удаляем все данные пользователя
    keys = ['name', 'age', 'medication', 'diagnosis', 'history', 'last_stress_level']
    for key in keys:
        if key in context.user_data:
            del context.user_data[key]

    await update.message.reply_text(
        "🔁 Все ваши данные были сброшены. Давайте начнем регистрацию заново.\n"
        "👤 Как вас зовут?",
        reply_markup=ReplyKeyboardRemove()
    )
    return NAME

# юзер
async def show_user_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_data = context.user_data
    if not all(key in user_data for key in ['name', 'age', 'medication', 'diagnosis']):
        await update.message.reply_text(
            "👤 Как вас зовут?",
            reply_markup=ReplyKeyboardRemove()
        )
        return NAME

    text = (
        f"📋 Ваши данные:\n\n"
        f"Имя: {user_data['name']}\n"
        f"Возраст: {user_data['age']}\n"
        f"Принимает препараты: {user_data['medication']}\n"
        f"Медицинские диагнозы: {user_data['diagnosis']}\n\n"
        f"Вы можете изменить или сбросить данные"
    )

    await update.message.reply_text(text, reply_markup=edit_data_menu)
    return ConversationHandler.END

# выговориться
async def start_vent(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "С чем хочешь поделиться?",
        reply_markup=news_type_keyboard
    )
    return NEWS_TYPE


async def choose_news_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "Назад":
        await update.message.reply_text(
            "Главное меню:",
            reply_markup=main_menu
        )
        return ConversationHandler.END

    context.user_data['news_type'] = text.lower()

    if text == "Хорошая новость":
        await update.message.reply_text(
            "Отлично! О чем именно хочешь рассказать?",
            reply_markup=good_news_keyboard
        )
    elif text == "Плохая новость":
        await update.message.reply_text(
            "Я слушаю. О чем хочешь поговорить?",
            reply_markup=bad_news_keyboard
        )
    else:
        await update.message.reply_text(
            "Пожалуйста, выбери тип новости из предложенных",
            reply_markup=news_type_keyboard
        )
        return NEWS_TYPE

    return NEWS_CATEGORY

USED_RESPONSES = {}

async def send_dialog_response(update, context, news_type, category):
    key = (news_type, category)

    # Все возможные ответы для данной категории
    all_responses = DIALOG_RESPONSES[news_type][category]

    # Берём использованные ответы (если уже есть)
    used_responses = USED_RESPONSES.get(key, set())

    # Если использованы все — сбрасываем
    if len(used_responses) >= len(all_responses):
        used_responses = set()

    # Получаем список ещё не использованных фраз
    available_responses = [resp for resp in all_responses if resp not in used_responses]

    # Выбираем случайный из оставшихся
    response = random.choice(available_responses)

    # Сохраняем, что использовали
    used_responses.add(response)
    USED_RESPONSES[key] = used_responses

    await update.message.reply_text(
        response,
        reply_markup=dialog_keyboard
    )
    return IN_DIALOG

async def handle_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    category = update.message.text
    news_type = context.user_data.get('news_type', '')

    if category == "Назад":
        await update.message.reply_text(
            "С чем хочешь поделиться?",
            reply_markup=news_type_keyboard
        )
        return NEWS_TYPE

    if news_type in DIALOG_RESPONSES and category in DIALOG_RESPONSES[news_type]:
        context.user_data['current_category'] = category
        # Выбираем случайный ответ для этой категории
        response = random.choice(DIALOG_RESPONSES[news_type][category])
        await update.message.reply_text(
            response,
            reply_markup=dialog_keyboard
        )
        return IN_DIALOG

    await update.message.reply_text(
        "Пожалуйста, выбери категорию из предложенных",
        reply_markup=good_news_keyboard if news_type == 'хорошая новость' else bad_news_keyboard
    )
    return NEWS_CATEGORY

    if news_type in DIALOG_RESPONSES and category in DIALOG_RESPONSES[news_type]:
        context.user_data['current_category'] = category

        # Первое сообщение при выборе категории
        initial_prompts = {
            'хорошая новость': {
                'Учеба': "Расскажи подробнее о своих успехах в учебе!",
                'Работа': "Поделись, что хорошего произошло на работе?",
                'Семья': "Что приятного случилось в семье?",
                'Здоровье': "Как улучшилось твое здоровье?",
                'Личные отношения': "Что хорошего в твоих отношениях?",
                'Хобби и увлечения': "Чем порадовало твое хобби?",
                'Финансы': "Какие финансовые успехи ты хочешь отметить?",
                'Путешествия': "Какими приятными моментами из путешествий хочешь поделиться?"
            },
            'плохая новость': {
                'Учеба': "Расскажи, что именно случилось?",
                'Работа': "Что произошло на работе?",
                'Семья': "Что беспокоит в семье?",
                'Здоровье': "Что случилось с твоим здоровьем?",
                'Личные отношения': "Что тревожит в отношениях?",
                'Хобби и увлечения': "Что огорчило в твоем увлечении?",
                'Финансы': "Какие финансовые трудности возникли?",
                'Путешествия': "Что пошло не так в путешествиях?"
            }
        }

        await update.message.reply_text(
            initial_prompts[news_type][category],
            reply_markup=dialog_keyboard
        )
        return IN_DIALOG

    await update.message.reply_text(
        "Пожалуйста, выбери категорию из предложенных",
        reply_markup=good_news_keyboard if news_type == 'хорошая новость' else bad_news_keyboard
    )
    return NEWS_CATEGORY


async def start_dialog(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text.lower()

    if "завершить" in user_text:
        await update.message.reply_text(
            "Диалог завершен. Всегда рада выслушать тебя снова!",
            reply_markup=main_menu
        )
        return ConversationHandler.END


    # Получаем категорию и тип из контекста
    category = context.user_data.get('current_category')
    news_type = context.user_data.get('news_type')

    if category and news_type and news_type in DIALOG_RESPONSES and category in DIALOG_RESPONSES[news_type]:
        # На каждое сообщение пользователя отвечаем новым случайным ответом из категории
        response = random.choice(DIALOG_RESPONSES[news_type][category])
        await update.message.reply_text(
            response,
            reply_markup=dialog_keyboard
        )
        return IN_DIALOG

    await update.message.reply_text("Давай начнем сначала", reply_markup=main_menu)
    return ConversationHandler.END


async def choose_news_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    context.user_data['news_type'] = text.lower()

    if text == "Хорошая новость":
        await update.message.reply_text(
            "Отлично! О чем именно хочешь рассказать?",
            reply_markup=good_news_keyboard
        )
    elif text == "Плохая новость":
        await update.message.reply_text(
            "Я слушаю. О чем хочешь поговорить?",
            reply_markup=bad_news_keyboard
        )
    else:
        await update.message.reply_text(
            "Выбери тип новости",
            reply_markup=news_type_keyboard
        )
        return NEWS_TYPE

    return NEWS_CATEGORY


async def handle_category(update: Update, context: ContextTypes.DEFAULT_TYPE):
    category = update.message.text
    news_type = context.user_data.get('news_type', '')

    if category == "Назад":
        await update.message.reply_text(
            "С чем хочешь поделиться?",
            reply_markup=news_type_keyboard
        )
        return NEWS_TYPE

    if news_type in DIALOG_RESPONSES and category in DIALOG_RESPONSES[news_type]:
        context.user_data['current_category'] = category
        response = random.choice(DIALOG_RESPONSES[news_type][category])
        await update.message.reply_text(
            response,
            reply_markup=dialog_keyboard
        )
        return IN_DIALOG

    await update.message.reply_text(
        "Пожалуйста, выбери категорию из предложенных",
        reply_markup=good_news_keyboard if news_type == 'хорошая новость' else bad_news_keyboard
    )
    return NEWS_CATEGORY


async def continue_dialog(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_text = update.message.text.lower()

    if "завершить" in user_text:
        await update.message.reply_text(
            "Диалог завершен. Всегда рада выслушать тебя снова!",
            reply_markup=main_menu
        )
        return ConversationHandler.END

    # Получаем текущий контекст диалога
    news_type = context.user_data.get('news_type')
    category = context.user_data.get('current_category')

    if news_type and category and news_type in DIALOG_RESPONSES and category in DIALOG_RESPONSES[news_type]:
        response = random.choice(DIALOG_RESPONSES[news_type][category])
        await update.message.reply_text(
            response,
            reply_markup=dialog_keyboard
        )
        return IN_DIALOG

    await update.message.reply_text("Давай начнем сначала", reply_markup=main_menu)
    return ConversationHandler.END

    responses = {
        'хорошая новость': {
            'Учеба': "Что нового в учебе? Может, есть какой-то интересный проект или успех?",
            'Работа': "Как идут дела на работе? Есть что-то, чем особенно гордишься? Поделись!",
            'Семья': "Как там дома? Какие новости у родных? Буду рада услышать :)",
            'Здоровье': "Как самочувствие? Надеюсь, все становится только лучше! Потому что заслуживаешь этого",
            'Личные отношения': "Что нового в личной жизни? Есть что-то, что стоит отметить? Я вся во внимании :)",
            'Хобби и увлечения': "Как идут дела с увлечениями? Пробовал что-то новое или достиг чего-то интересного? Рассказывай!",
            'Финансы': "Как идут финансовые дела? Удалось ли что-то запланировать или приобрести?",
            'Путешествия': "Какие планы на следующие путешествия? Есть место, которое хочешь посетить?"
        },
        'плохая новость': {
            'Учеба': "Жаль слышать. Что случилось? Давай разберемся, может, есть способ улучшить ситуацию.",
            'Работа': "Понимаю, это может быть неприятно. Что произошло? Может, есть какие-то шаги, чтобы это исправить?",
            'Семья': "Очень жаль. Если хочешь поговорить или поделиться, я здесь.",
            'Здоровье': "Мне очень жаль это слышать. Надеюсь, что скоро все наладится. Как ты себя чувствуешь сейчас?",
            'Личные отношения': "Это тяжело. Хочешь поговорить об этом? Возможно, стоит обсудить, как можно улучшить ситуацию.",
            'Хобби и увлечения': "Очень грустно слышать. Может, стоит сделать небольшой перерыв и вернуться к этому позже?",
            'Финансы': "Это неприятно. Может быть, есть какой-то план или помощь, которая могла бы тебе помочь?",
            'Путешествия': "Очень жаль, что так получилось. Надеюсь, что скоро будет шанс снова поехать. Что произошло?"
        }
    }


    if category == "Назад":
        await update.message.reply_text(
            "С чем хочешь поделиться?",
            reply_markup=news_type_keyboard
        )
        return NEWS_TYPE

    if news_type in responses and category in responses[news_type]:
        await update.message.reply_text(
            responses[news_type][category],
            reply_markup=main_menu
        )
        return ConversationHandler.END
    else:
        await update.message.reply_text(
            "Пожалуйста, выбери категорию из предложенных",
            reply_markup=good_news_keyboard if news_type == 'хорошая новость' else bad_news_keyboard
        )
        return NEWS_CATEGORY


async def start_edit_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Что вы хотите изменить?",
        reply_markup=choose_field_menu
    )
    return CHOOSE_FIELD


async def choose_field(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "Имя":
        await update.message.reply_text("Введите новое имя:", reply_markup=ReplyKeyboardRemove())
        return EDIT_NAME
    elif text == "Возраст":
        await update.message.reply_text("Выберите возрастную категорию:", reply_markup=age_keyboard)
        return EDIT_AGE
    elif text == "Препараты":
        await update.message.reply_text("Принимаете ли вы препараты?", reply_markup=yes_no_keyboard)
        return EDIT_MEDICATION
    elif text == "Диагнозы":
        await update.message.reply_text("Есть ли медицинские диагнозы?", reply_markup=yes_no_keyboard)
        return EDIT_DIAGNOSIS
    else:
        await update.message.reply_text("Главное меню:", reply_markup=main_menu)
        return ConversationHandler.END


async def edit_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['name'] = update.message.text
    await update.message.reply_text(
        f"✅ Имя успешно изменено на {update.message.text}!",
        reply_markup=main_menu
    )
    return ConversationHandler.END


async def edit_age(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['age'] = update.message.text
    await update.message.reply_text(
        f"✅ Возрастная категория изменена на {update.message.text}!",
        reply_markup=main_menu
    )
    return ConversationHandler.END


async def edit_medication(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "Нет":
        context.user_data['medication'] = "Не принимает препараты"
        context.user_data['medications'] = []
        await update.message.reply_text(
            "✅ Информация о препаратах обновлена: Не принимает препараты!",
            reply_markup=main_menu
        )
        return ConversationHandler.END
    else:
        context.user_data['medication'] = "Принимает препараты"
        context.user_data['medications'] = []  # Очищаем предыдущий список
        await update.message.reply_text(
            "Сколько препаратов вы принимаете?",
            reply_markup=med_count_keyboard
        )
        return MEDICATION_COUNT  # Запускаем тот же опрос



async def edit_diagnosis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['diagnosis'] = update.message.text
    await update.message.reply_text(
        f"✅ Информация о диагнозах обновлена: {update.message.text}!",
        reply_markup=main_menu
    )
    return ConversationHandler.END


async def get_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['name'] = update.message.text
    await update.message.reply_text(
        "Выберите возрастную категорию:",
        reply_markup=age_keyboard
    )
    return AGE


async def get_age(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['age'] = update.message.text
    await update.message.reply_text(
        "Принимаете ли вы препараты (гормоны/антидепрессанты)?",
        reply_markup=yes_no_keyboard
    )
    return MEDICATION


async def get_diagnosis(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['diagnosis'] = update.message.text
    name = context.user_data['name']
    await update.message.reply_text(
        f"Спасибо, {name}, ваши данные сохранены!",
        reply_markup=main_menu
    )
    return ConversationHandler.END


async def handle_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    scores = {"Никогда": 0, "Редко": 1, "Иногда": 2, "Часто": 3, "Постоянно": 4}
    context.user_data['test_score'] += scores.get(update.message.text, 0)
    context.user_data['test_step'] += 1

    if context.user_data['test_step'] < TEST_TOTAL:
        await update.message.reply_text(TEST[context.user_data['test_step']], reply_markup=test_keyboard)
        return TEST_QUESTIONS
    else:
        total = context.user_data['test_score']

        if total <= 5:
            level = "low"
        elif total <= 10:
            level = "medium"
        elif total <= 15:
            level = "high"
        else:
            level = "critical"

        context.user_data['last_stress_level'] = level

        result_text = f"Результат: {total}/20\n" + STRESS_ADVICE[level]

        timestamp = datetime.now().strftime("%d.%m.%Y %H:%M")
        history = context.user_data.setdefault("history", [])
        history.append(f"{timestamp} — {total}/20")

        with open("stress_results.txt", "a", encoding="utf-8") as file:
            file.write(f"{timestamp} — {update.effective_user.id} — {total}/20\n")

        await update.message.reply_text(
            result_text + "\n\nХотите подробные рекомендации?",
            reply_markup=result_keyboard
        )
        return ConversationHandler.END


async def handle_panic_test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if 'panic_test' not in context.user_data:
        context.user_data['panic_test'] = {'step': 0, 'score': 0}

    if update.message.text in ["Да", "Нет"]:
        if update.message.text == "Да":
            context.user_data['panic_test']['score'] += 1
        context.user_data['panic_test']['step'] += 1

    if context.user_data['panic_test']['step'] < len(PANIC_TEST):
        await update.message.reply_text(
            PANIC_TEST[context.user_data['panic_test']['step']],
            reply_markup=yes_no_keyboard
        )
        return TEST_PANIC_QUESTIONS
    else:
        score = context.user_data['panic_test']['score']
        level = min(3, score)  # Определяем уровень от 0 до 3

        # Сохраняем результаты (без показа пользователю)
        timestamp = datetime.now().strftime("%d.%m.%Y %H:%M")
        with open("panic_results.txt", "a", encoding="utf-8") as file:
            file.write(f"{timestamp} — {update.effective_user.id} — {score}\n")

        # Даем соответствующие рекомендации
        technique = PANIC_TECHNIQUES[level]
        await update.message.reply_text(
            technique["message"],
            reply_markup=technique["keyboard"],
            parse_mode="Markdown"
        )

        # Для критического уровня добавляем дополнительную проверку
        if level >= 2:
            context.user_data['need_followup'] = True
        return ConversationHandler.END


async def handle_followup(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    if text == "Я начинаю дышать":
        await update.message.reply_text(
            "👍 Отлично! Продолжайте дышать в том же ритме. "
            "С каждым выдохом тревога уменьшается. "
            "Вы замечательно справляетесь! Через 2 минуты я проверю, как вы себя чувствуете.",
            reply_markup=ReplyKeyboardMarkup(
                [["Стало лучше"], ["Все еще тяжело"]],
                resize_keyboard=True
            )
        )
    elif text == "Я справился(ась)":
        await update.message.reply_text(
            "🎉 Я горжусь вами! Это было непросто, но вы смогли! "
            "Обязательно похвалите себя за эту победу.",
            reply_markup=main_menu
        )
    elif text == "Стало лучше":
        await update.message.reply_text(
            "🌤️ Прекрасные новости! Вы большая умничка! "
            "Помните — это состояние временное, а вы сильнее, чем думаете.",
            reply_markup=main_menu
        )
    elif text == "Все еще тяжело":
        await update.message.reply_text(
            "🆘 Пожалуйста, позвоните на горячую линию 150. "
            "Вы не одни, и помощь уже рядом. Я остаюсь с вами.",
            reply_markup=ReplyKeyboardMarkup(
                [["Горячая линия"], ["Я позвонил(а)"]],
                resize_keyboard=True
            )
        )
    elif text == "Я позвонил(а)":
        await update.message.reply_text(
            "💙 Вы сделали правильный выбор. Специалисты помогут вам. "
            "Я здесь, если вам нужно будет поговорить позже.",
            reply_markup=main_menu
        )
    return ConversationHandler.END


async def extended_advice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    level = context.user_data.get('last_stress_level')
    if level in EXTENDED_ADVICE:
        await update.message.reply_text(
            EXTENDED_ADVICE[level],
            reply_markup=result_keyboard
        )
    else:
        await update.message.reply_text(
            "Сначала пройдите тест для получения рекомендаций",
            reply_markup=main_menu
        )


async def share_experience(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text

    if text == "Вернуться в меню":
        await update.message.reply_text(
            "Возвращаемся в главное меню.",
            reply_markup=main_menu
        )
        return ConversationHandler.END

    # Сохраняем сообщение пользователя
    timestamp = datetime.now().strftime("%d.%m.%Y %H:%M")
    with open("user_experiences.txt", "a", encoding="utf-8") as file:
        file.write(f"{timestamp} — {update.effective_user.id} — {text}\n")

    await update.message.reply_text(
        "Спасибо, что поделились. Ваши переживания важны.\n"
        "Можете продолжить или вернуться в меню.",
        reply_markup=ReplyKeyboardMarkup(
            [["Вернуться в меню"]],
            resize_keyboard=True
        )
    )
    return SHARE_EXPERIENCE


async def handle_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text

    if text == "Вернуться в меню":
        await update.message.reply_text(
            "Главное меню:",
            reply_markup=main_menu
        )
        return ConversationHandler.END

    elif text == "Рассказать о себе":
        return await show_user_data(update, context)

    elif text == "Изменить данные":
        return await start_edit_data(update, context)

    elif text == "Сбросить данные":
        return await reset_data(update, context)

    elif text == "Пройти тест уровня стресса":
        context.user_data['test_step'] = 0
        context.user_data['test_score'] = 0
        await update.message.reply_text(
            "Начнём тест. Отвечайте честно:",
            reply_markup=test_keyboard
        )
        await update.message.reply_text(TEST[0])
        return TEST_QUESTIONS

    elif text == "Расскажи побольше":
        return await extended_advice(update, context)

    elif text == "Выговориться":
        await update.message.reply_text(
            "💬 Напишите всё, что вас беспокоит. Я внимательно выслушаю:",
            reply_markup=ReplyKeyboardMarkup(
                [["Вернуться в меню"]],
                resize_keyboard=True
            )
        )
        return SHARE_EXPERIENCE

    elif text == "Мои результаты уровня стресса":
        history = context.user_data.get("history", [])
        if not history:
            await update.message.reply_text("❗️Вы ещё не проходили тест.", reply_markup=main_menu)
        else:
            await update.message.reply_text("📊 Ваши результаты:\n" + "\n".join(history), reply_markup=main_menu)
        return ConversationHandler.END

    elif text == "Срочная помощь":
        await update.message.reply_text(
            "Сейчас проведем быстрый тест (5 вопросов), чтобы подобрать лучшую технику помощи.\n"
            "Отвечайте «Да» или «Нет»:",
            reply_markup=yes_no_keyboard
        )
        context.user_data['panic_test'] = {'step': 0, 'score': 0}
        await update.message.reply_text(PANIC_TEST[0], reply_markup=yes_no_keyboard)
        return TEST_PANIC_QUESTIONS

    elif text == "Горячая линия":
        await update.message.reply_text(
            "📞 Телефоны помощи:\n\n"
            "• Кризисная линия: 150 (круглосуточно)\n"
            "• Для детей: 8-800-2000-122\n"
            "• Психологи МЧС: 8-495-989-50-50\n\n"
            "Не стесняйтесь обращаться за помощью!",
            reply_markup=main_menu
        )
        return ConversationHandler.END

    else:
        await update.message.reply_text("Пожалуйста, выберите действие из меню.", reply_markup=main_menu)
        return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Действие отменено.",
        reply_markup=main_menu
    )
    return ConversationHandler.END


def main():
    application = ApplicationBuilder().token("MYTOKEN").build()

    info_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Рассказать о себе$"), handle_menu)],
        states={
            NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)],
            AGE: [MessageHandler(filters.Regex("^(12-18|19-25|26-35|36-45|46-60)$"), get_age)],
            MEDICATION: [MessageHandler(filters.Regex("^(Да|Нет)$"), get_medication)],
            MEDICATION_COUNT: [MessageHandler(filters.Regex("^(1|2|3|4|5\+)$"), get_medication_count)],
            MEDICATION_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_medication_type)],
            MEDICATION_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_medication_name)],
            MEDICATION_REMINDER: [MessageHandler(filters.Regex("^(Да|Нет)$"), get_medication_reminder)],
            MEDICATION_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_medication_time)],
            DIAGNOSIS: [MessageHandler(filters.Regex("^(Да|Нет)$"), get_diagnosis)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    reset_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Сбросить данные$"), reset_data)],
        states={
            NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)],
            AGE: [MessageHandler(filters.Regex("^(12-18|19-25|26-35|36-45|46-60)$"), get_age)],
            MEDICATION: [MessageHandler(filters.Regex("^(Да|Нет)$"), get_medication)],
            DIAGNOSIS: [MessageHandler(filters.Regex("^(Да|Нет)$"), get_diagnosis)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    assessment_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Оценка состояния$"), start_assessment)],
        states={
            ASSESSMENT_QUESTIONS: [MessageHandler(filters.Regex("^[0-4]$"), process_assessment_answer)],
        },
        fallbacks=[],
    )

    test_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Пройти тест уровня стресса$"), handle_menu)],
        states={
            TEST_QUESTIONS: [MessageHandler(filters.Regex("^(Никогда|Редко|Иногда|Часто|Постоянно)$"), handle_test)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    vent_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Выговориться$"), start_vent)],
        states={
            NEWS_TYPE: [MessageHandler(filters.Regex("^(Хорошая новость|Плохая новость|Назад)$"), choose_news_type)],
            NEWS_CATEGORY: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_category)],
            IN_DIALOG: [MessageHandler(filters.TEXT & ~filters.COMMAND, continue_dialog)]
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    application.add_handler(vent_conv)

    panic_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Срочная помощь$"), handle_menu)],
        states={
            TEST_PANIC_QUESTIONS: [MessageHandler(filters.Regex("^(Да|Нет)$"), handle_panic_test)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    share_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Выговориться$"), handle_menu)],
        states={
            SHARE_EXPERIENCE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, share_experience),
                MessageHandler(filters.Regex("^Вернуться в меню$"), handle_menu)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )



    edit_conv = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex("^Изменить данные$"), start_edit_data)],
        states={
            CHOOSE_FIELD: [MessageHandler(filters.TEXT & ~filters.COMMAND, choose_field)],
            EDIT_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, edit_name)],
            EDIT_AGE: [MessageHandler(filters.Regex("^(12-18|19-25|26-35|36-45|46-60)$"), edit_age)],
            EDIT_MEDICATION: [MessageHandler(filters.Regex("^(Да|Нет)$"), edit_medication)],
            EDIT_DIAGNOSIS: [MessageHandler(filters.Regex("^(Да|Нет)$"), edit_diagnosis)],
            # Добавляем состояния для опроса о препаратах
            MEDICATION_COUNT: [MessageHandler(filters.Regex("^(1|2|3|4|5\+)$"), get_medication_count)],
            MEDICATION_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_medication_type)],
            MEDICATION_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_medication_name)],
            MEDICATION_REMINDER: [MessageHandler(filters.Regex("^(Да|Нет)$"), get_medication_reminder)],
            MEDICATION_TIME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_medication_time)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    followup_conv = ConversationHandler(
        entry_points=[
            MessageHandler(
                filters.Regex("^(Я начинаю дышать|Я справился\(ась\)|Стало лучше|Все еще тяжело|Я позвонил\(а\))$"),
                handle_followup)
        ],
        states={},
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    # Регистрация обработчиков
    application.add_handler(CommandHandler("start", start))
    application.add_handler(assessment_conv)
    application.add_handler(info_conv)
    application.add_handler(reset_conv)
    application.add_handler(test_conv)
    application.add_handler(panic_conv)
    application.add_handler(share_conv)
    application.add_handler(edit_conv)
    application.add_handler(followup_conv)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_menu))

    # Запуск бота
    application.run_polling()


if __name__ == "__main__":
    main()

